package pg

import (
	"crypto/rand"
	"database/sql"
	"fmt"
	"time"

	"github.com/google/uuid"

	"github.com/nextlevelbuilder/goclaw/internal/store"
)

const (
	codeAlphabet         = "ABCDEFGHJKLMNPQRSTUVWXYZ23456789"
	codeLength           = 8
	codeTTL              = 60 * time.Minute
	maxPendingPerAccount = 3
)

// PGPairingStore implements store.PairingStore backed by Postgres.
type PGPairingStore struct {
	db *sql.DB
}

func NewPGPairingStore(db *sql.DB) *PGPairingStore {
	return &PGPairingStore{db: db}
}

func (s *PGPairingStore) RequestPairing(senderID, channel, chatID, accountID string) (string, error) {
	// Prune expired
	s.db.Exec("DELETE FROM pairing_requests WHERE expires_at < $1", time.Now())

	// Check max pending
	var count int64
	s.db.QueryRow("SELECT COUNT(*) FROM pairing_requests WHERE account_id = $1", accountID).Scan(&count)
	if count >= maxPendingPerAccount {
		return "", fmt.Errorf("max pending pairing requests (%d) exceeded", maxPendingPerAccount)
	}

	// Check existing
	var existingCode string
	err := s.db.QueryRow("SELECT code FROM pairing_requests WHERE sender_id = $1 AND channel = $2", senderID, channel).Scan(&existingCode)
	if err == nil {
		return existingCode, nil
	}

	code := generatePairingCode()
	now := time.Now()
	_, err = s.db.Exec(
		`INSERT INTO pairing_requests (id, code, sender_id, channel, chat_id, account_id, expires_at, created_at)
		 VALUES ($1, $2, $3, $4, $5, $6, $7, $8)`,
		uuid.Must(uuid.NewV7()), code, senderID, channel, chatID, accountID, now.Add(codeTTL), now,
	)
	if err != nil {
		return "", fmt.Errorf("create pairing request: %w", err)
	}
	return code, nil
}

func (s *PGPairingStore) ApprovePairing(code, approvedBy string) (*store.PairedDeviceData, error) {
	// Prune expired
	s.db.Exec("DELETE FROM pairing_requests WHERE expires_at < $1", time.Now())

	var reqID uuid.UUID
	var senderID, channel, chatID string
	err := s.db.QueryRow(
		"SELECT id, sender_id, channel, chat_id FROM pairing_requests WHERE code = $1", code,
	).Scan(&reqID, &senderID, &channel, &chatID)
	if err != nil {
		return nil, fmt.Errorf("pairing code %s not found or expired", code)
	}

	// Remove from pending
	s.db.Exec("DELETE FROM pairing_requests WHERE id = $1", reqID)

	// Add to paired
	now := time.Now()
	_, err = s.db.Exec(
		`INSERT INTO paired_devices (id, sender_id, channel, chat_id, paired_by, paired_at)
		 VALUES ($1, $2, $3, $4, $5, $6)`,
		uuid.Must(uuid.NewV7()), senderID, channel, chatID, approvedBy, now,
	)
	if err != nil {
		return nil, fmt.Errorf("create paired device: %w", err)
	}

	return &store.PairedDeviceData{
		SenderID: senderID,
		Channel:  channel,
		ChatID:   chatID,
		PairedAt: now.UnixMilli(),
		PairedBy: approvedBy,
	}, nil
}

func (s *PGPairingStore) RevokePairing(senderID, channel string) error {
	result, err := s.db.Exec("DELETE FROM paired_devices WHERE sender_id = $1 AND channel = $2", senderID, channel)
	if err != nil {
		return err
	}
	n, _ := result.RowsAffected()
	if n == 0 {
		return fmt.Errorf("paired device not found: %s/%s", channel, senderID)
	}
	return nil
}

func (s *PGPairingStore) IsPaired(senderID, channel string) bool {
	var count int64
	s.db.QueryRow("SELECT COUNT(*) FROM paired_devices WHERE sender_id = $1 AND channel = $2", senderID, channel).Scan(&count)
	return count > 0
}

func (s *PGPairingStore) ListPending() []store.PairingRequestData {
	// Prune expired
	s.db.Exec("DELETE FROM pairing_requests WHERE expires_at < $1", time.Now())

	rows, err := s.db.Query(
		"SELECT code, sender_id, channel, chat_id, account_id, created_at, expires_at FROM pairing_requests ORDER BY created_at DESC")
	if err != nil {
		return nil
	}
	defer rows.Close()

	var result []store.PairingRequestData
	for rows.Next() {
		var d store.PairingRequestData
		var createdAt, expiresAt time.Time
		if err := rows.Scan(&d.Code, &d.SenderID, &d.Channel, &d.ChatID, &d.AccountID, &createdAt, &expiresAt); err != nil {
			continue
		}
		d.CreatedAt = createdAt.UnixMilli()
		d.ExpiresAt = expiresAt.UnixMilli()
		result = append(result, d)
	}
	if result == nil {
		return []store.PairingRequestData{}
	}
	return result
}

func (s *PGPairingStore) ListPaired() []store.PairedDeviceData {
	rows, err := s.db.Query("SELECT sender_id, channel, chat_id, paired_by, paired_at FROM paired_devices ORDER BY paired_at DESC")
	if err != nil {
		return nil
	}
	defer rows.Close()

	var result []store.PairedDeviceData
	for rows.Next() {
		var d store.PairedDeviceData
		var pairedAt time.Time
		if err := rows.Scan(&d.SenderID, &d.Channel, &d.ChatID, &d.PairedBy, &pairedAt); err != nil {
			continue
		}
		d.PairedAt = pairedAt.UnixMilli()
		result = append(result, d)
	}
	if result == nil {
		return []store.PairedDeviceData{}
	}
	return result
}

func generatePairingCode() string {
	b := make([]byte, codeLength)
	rand.Read(b)
	code := make([]byte, codeLength)
	for i := range code {
		code[i] = codeAlphabet[int(b[i])%len(codeAlphabet)]
	}
	return string(code)
}
